<?php
/**
 * Model, REST Resource entity
 */
namespace Resto\Entity;

use Resto\Common\Str;
use Resto\Common\Resource;
use Resto\Relations\HasMany;
use Resto\Relations\HasOne;
use Resto\Relations\BelongsTo;

class Model
{
	/**
	 * Collection Path
	 */
	protected $collection_path;

	/**
	 * Unique identifier key
	 * @var string
	 */
	protected $key = 'id';
	
	protected $attributes = array();

	/**
	 * Valid attributes for the entity.
	 * If specified, will be filtered before doing the API request
	 * @var [type]
	 */
	protected $fillable   = array();

	public static function find()
	{

	}

	/**
	 * Get the resource instance for this model
	 * @return Resto\Common\Resource
	 */
	public static function getResource()
	{
		return Resource::resolve(get_called_class());
	}

	/**
	 * Get HTTP request object to add more params.
	 * @return [type] [description]
	 */
	public static function query()
	{

	}

	/**
	 * Fill and make a model
	 * @param  array $data
	 */
	protected function fill(Array $data)
	{
		foreach ($data as $key => $value)
			$this->setAttribute($key, $value);
	}

	/**
	 * Set attribute to attribute array.
	 * @param string $key
	 * @param string|int $value
	 */
	public function setAttribute($key, $value)
	{	
		$mutator_method = $this->generateSetMutatorName($key);
		
		if (method_exists($this, $mutator_method))
			$this->$mutator_method($key, $value);
		else
			$this->attributes[$key] = $value;	
	}

	/**
	 * Get an attribute
	 * @param  string $key
	 * @return mixed
	 */
	public function getAttribute($key)
	{	
		$mutator_method = $this->generateGetMutatorName($key);
		
		if (method_exists($this, $mutator_method)) {
			return $this->$mutator_method($key);
		} else {
			if (array_key_exists($key, $this->attributes));
				return $this->attributes[$key];
		}
			
	}

	/**
	 * Generate mutator method's name to set attribute. Used to check if method exists
	 * @param  string $key method name
	 * @return string
	 */
	protected function generateSetMutatorName($key)
	{
		$key    = Str::studly($key);
		return "set{$key}Attribute";
	}

	/**
	 * Generate mutator method's name to get attribute. Used to check if method exists
	 * @param  string $key method name
	 * @return string
	 */
	protected function generateGetMutatorName($key)
	{
		$key    = Str::studly($key);
		return "get{$key}Attribute";
	}

	/**
	 * Get Collection path for same type of entities. Typically generated by pluralizing class name.
	 * Used when creating new objects. ie:- POST /users
	 */
	public function getCollectionPath()
	{
		if (!$this->collection_path)
			return Str::collectionPath(get_called_class());
		else
			return $this->collection_path;
	}

	/**
	 * Path of an entity instance. If not provided, generated using collection path and current
	 * instance's id. Used to update an object.
	 * PUT/DELETE /tickets/{id}
	 * @return [type] [description]
	 */
	public function getEntityPath()
	{
		$parts   = array();
		$parts[] = $this->getCollectionPath();
		
		if ($entity_id = $this->{$this->key})
			$parts[] = $entity_id;

		return implode('/', $parts);
	}

	public function hasMany($class, $path = false)
	{
		return $this->generateRelation('HasMany', $class, $path);
	}

	public function hasOne($class, $path = false)
	{
		return $this->generateRelation('HasOne', $class, $path);
	}

	/**
	 * Build a relation object, used by hasMany, hasOne, belongsTo helpers.
	 * On initiate, it will append the current namespace to relating class.
	 * @param  string $type  - type of the relation, the class name of Relation, HasOne, HasMany, Belongs to, under Resto\Relation\..
	 * @param  string $class - relating clas name
	 * @param  string $path  - custom query path
	 * @return Resto\Relation
	 */
	protected function generateRelation($type, $class, $path)
	{
		$namespace = static::getResource()->getNamespace();
		$fqclass   = "{$namespace}\\{$class}";

		switch ($type) {
			case 'HasMany':
					return new HasMany($fqclass, $this, $path);
				break;
			
			case 'HasOne':
					return new HasOne($fqclass, $this, $path);
				break;
		}
			
	}

	public function __set($property, $value)
	{
		return $this->setAttribute($property, $value);
	}

	public function __get($property)
	{
		return $this->getAttribute($property);
	}
}